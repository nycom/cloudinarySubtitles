{"version":3,"sources":["ng://cloudinary-subtitle-lib/lib/cloudinary-subtitle-lib.service.ts"],"names":["CloudinarySubtitleLibService","prototype","addSubtitlesToVideo","cloudName","videoPublicId","subtitles","length","url","this","BASE_URL","CLOUDINARY_URL_VIDEO_TYPE_EXTENSION","map","entry","_this","entryToCloudinaryParams","console","error","addTextAndPosition","text","parseTimeToParam","encodeURIComponent","prefix","time","timeArray","split","sec","min","parseFloat","pop","Injectable","args","providedIn"],"mappings":"4RAAA,IAAAA,EAAA,WAWE,SAAAA,kBAHW,uEAC2B,wBAI/BA,EAAAC,UAAAC,6BAAoBC,EAAmBC,EAAuBC,cAEnE,GAAIF,GAAkC,IAArBA,EAAUG,OAO3B,GAAIF,GAA0C,IAAzBA,EAAcE,OAAnC,CAQA,GAAID,GAAcA,EAAUA,WAA4C,IAA/BA,EAAUA,UAAUC,OAA7D,CAQA,IAAIC,EAAMC,KAAKC,SAAWN,EAAYK,KAAKE,oCAQ3C,OAPuBL,EAAUA,UAElBM,IAAI,SAAAC,GACjBL,GAAOM,EAAKC,wBAAwBF,KAGtCL,GAAOH,EAdLW,QAAQC,MAAM,4SARdD,QAAQC,MAAM,kOAPdD,QAAQC,MAAM,+NAiCVhB,EAAAC,UAAAa,iCAAwBF,GAC9B,OAAQJ,KAAKS,mBAAmBL,EAAMM,MACpCV,KAAKW,iBAAiB,MAAOP,EAAM,iBAAmB,IACtDJ,KAAKW,iBAAiB,MAAOP,EAAM,eAAiB,KAGhDZ,EAAAC,UAAAgB,4BAAmBC,GACzB,MAAO,qBAAuBE,mBAAmBA,mBAAmBF,IAAS,mCAGvElB,EAAAC,UAAAkB,0BAAiBE,EAAQC,GAI/B,IAHA,IAAIC,EAAYD,EAAKE,MAAM,KACzBC,EAAM,EAAGC,EAAM,EAES,EAAnBH,EAAUjB,QACfmB,GAAOC,EAAMC,WAAWJ,EAAUK,OAClCF,GAAO,GAET,OAAOL,EAASI,uBAjEnBI,EAAAA,WAAUC,KAAA,CAAC,CACVC,WAAY,sJAHd","sourcesContent":["import {Injectable} from '@angular/core';\n\n@Injectable({\n  providedIn: 'root'\n})\n\nexport class CloudinarySubtitleLibService {\n\n  BASE_URL = 'https://res.cloudinary.com/';\n  CLOUDINARY_URL_VIDEO_TYPE_EXTENSION = '/video/upload/';\n\n  constructor() {}\n\n  public addSubtitlesToVideo(cloudName: string, videoPublicId: string, subtitles: any) {\n\n    if(!cloudName || cloudName.length === 0){\n      console.error(`Missing or empty appropriate cloudName...\n                     cloudName should be a string which represents your cloud name provided by cloudinary,\\n\n                     please follow the instructions and try again`);\n      return;\n    }\n\n    if(!videoPublicId || videoPublicId.length === 0){\n      console.error(`Missing appropriate videoPublicId...\\n\n                     videoPublicId should be a string which represents the video id provided by cloudinary,\\n \n                     please follow the instructions and try again`);\n\n      return;\n    }\n\n    if(!subtitles || !subtitles.subtitles || subtitles.subtitles.length === 0){\n      console.error(`Missing or bad appropriate subtitles JSON...\\n\n                     the appropriate subtitles JSON should be of type:\\n\n                     { subtitles: { 'start-timing': string, 'end-timing': string, text: string }[] }\\n\n                     please follow the instructions and try again`);\n      return;\n    }\n\n    let url = this.BASE_URL + cloudName + this.CLOUDINARY_URL_VIDEO_TYPE_EXTENSION;\n    const subtitlesArray = subtitles.subtitles;\n\n    subtitlesArray.map(entry => {\n      url += this.entryToCloudinaryParams(entry);\n    });\n\n    url += videoPublicId;\n    return url;\n  }\n\n  private entryToCloudinaryParams(entry): string {\n    return (this.addTextAndPosition(entry.text) +\n      this.parseTimeToParam('so_', entry['start-timing']) + ',' +\n      this.parseTimeToParam('eo_', entry['end-timing']) + '/');\n  }\n\n  private addTextAndPosition(text): string {\n    return 'l_text:Arial_40px:' + encodeURIComponent(encodeURIComponent(text)) + ',y_60,g_south,b_black,co_white,';\n  }\n\n  private parseTimeToParam(prefix, time): string {\n    let timeArray = time.split(':'),\n      sec = 0, min = 1;\n\n    while (timeArray.length > 0) {\n      sec += min * parseFloat(timeArray.pop());\n      min *= 60;\n    }\n    return prefix + sec;\n  }\n}\n"]}